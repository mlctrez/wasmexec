package main

import (
	"bytes"
	"crypto/sha256"
	"fmt"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/magefile/mage/sh"
	"github.com/mlctrez/wasmexec/gitutil"
	"go/format"
	"os"
	"sort"
	"strings"
)

var Default = Build

func Build() (err error) {

	var file []byte
	file, err = os.ReadFile(".git/config")
	if err != nil {
		return
	}

	fmt.Println(string(file))

	os.Exit(0)

	gu := gitutil.New("https://github.com/golang/go", "/tmp/golang")

	if err = gu.CloneOrOpen(); err != nil {
		return
	}

	wasmExecPath := "misc/wasm/wasm_exec.js"

	var refs []*plumbing.Reference
	if refs, err = gu.Tags("go"); err != nil {
		return
	}

	var shaMapping = make(map[string]string)
	var contentMapping = make(map[string][]byte)

	for _, ref := range refs {
		var content []byte
		content, err = gu.Contents(wasmExecPath, ref)
		if os.IsNotExist(err) {
			continue
		}
		fmt.Printf("getting content for ref %s\n", ref.Name().Short())
		sum := shaContents(content)
		contentMapping[sum] = content
		shaMapping[ref.Name().Short()] = sum
	}

	var wasmExecContent []byte
	if wasmExecContent, err = buildWasmExec(shaMapping, contentMapping); err != nil {
		return
	}

	newSum := shaContents(wasmExecContent)

	var oldSum string
	if _, oldSum, err = readFileWithSha("versions.go"); err != nil {
		return
	}

	if newSum == oldSum {
		fmt.Println("no changes to file, exiting")
		return
	}

	if err = os.WriteFile("versions.go", wasmExecContent, 0644); err != nil {
		return
	}

	if err = sh.Run("git", "add", "versions.go"); err != nil {
		return
	}

	if err = sh.Run("git", "config", "--global", "user.email", "mlctrez@gmail.com"); err != nil {
		fmt.Println("err user.email")
		return
	}
	if err = sh.Run("git", "config", "--global", "user.name", "mlctrez"); err != nil {
		fmt.Println("err user.name")
		return
	}

	if err = sh.Run("git", "commit", "-m", "actions commit"); err != nil {
		fmt.Println("err commit")
		return
	}

	// TODO: bump version tag before commit

	fmt.Println("git push")
	if err = sh.Run("git", "push"); err != nil {
		fmt.Println("err git push")
		return
	}

	return
}

type SourceFile struct {
	buf *bytes.Buffer
}

func (sf *SourceFile) line(t string) *SourceFile {
	_, _ = sf.buf.WriteString(t + "\n")
	return sf
}

func (sf *SourceFile) format() (content []byte, err error) {
	return format.Source(sf.buf.Bytes())
}

func buildWasmExec(shaMapping map[string]string, contentMapping map[string][]byte) (content []byte, err error) {

	sf := &SourceFile{&bytes.Buffer{}}

	sf.line("package wasmexec")
	sf.line("// generated by https://github.com/mlctrez/wasmexec").line("")
	sf.line("import (").line(`"fmt"`).line(`"runtime"`).line(")")

	sf.line("func Current() (content []byte, err error) {")
	sf.line("return Version(runtime.Version())")
	sf.line("}").line("")

	sf.line("func Version(version string) (content []byte, err error) {").line("")

	sf.line("if contentFunc, ok := versionMap[version]; ok {")
	sf.line("content = []byte(contentFunc())")
	sf.line("}else{")
	sf.line(`err = fmt.Errorf("unsupported version %q", version)`)
	sf.line("}").line("")

	sf.line("return")
	sf.line("}").line("")

	var cmKeys []string
	for s := range contentMapping {
		cmKeys = append(cmKeys, s)
	}
	sort.Strings(cmKeys)

	for _, k := range cmKeys {
		sf.line(fmt.Sprintf("const %s = %q", shortSha(k), contentMapping[k]))
	}

	var goVersions []string
	for k := range shaMapping {
		goVersions = append(goVersions, k)
	}
	sort.Strings(goVersions)

	sf.line("var versionMap = map[string]func()string{")
	for _, goVersion := range goVersions {
		sf.line(fmt.Sprintf("%q: func() string { return %s },", goVersion, shortSha(shaMapping[goVersion])))
	}
	sf.line("}")

	return sf.format()
}

func shortSha(in string) string {
	return "sha" + strings.ToUpper(in[0:4]+in[64-4:])
}

func readFileWithSha(path string) (contents []byte, sum string, err error) {

	if contents, err = os.ReadFile(path); err != nil {
		return
	}

	sum = shaContents(contents)

	return
}

func shaContents(contents []byte) (sum string) {
	h := sha256.New()
	h.Write(contents)
	bs := h.Sum(nil)
	sum = fmt.Sprintf("%x", bs)
	return
}
